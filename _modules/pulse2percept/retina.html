

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pulse2percept.retina &mdash; pulse2percept 0.3.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="pulse2percept 0.3.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> pulse2percept
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pulse2percept</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pulse2percept.retina</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pulse2percept.retina</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">ss</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">spat</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">pulse2percept</span> <span class="k">import</span> <span class="n">utils</span>


<span class="n">SUPPORTED_LAYERS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;INL&#39;</span><span class="p">,</span> <span class="s1">&#39;GCL&#39;</span><span class="p">,</span> <span class="s1">&#39;OFL&#39;</span><span class="p">]</span>
<span class="n">SUPPORTED_TEMPORAL_MODELS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;latest&#39;</span><span class="p">,</span> <span class="s1">&#39;Nanduri2012&#39;</span><span class="p">,</span> <span class="s1">&#39;Horsager2009&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Grid"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid">[docs]</a><span class="k">class</span> <span class="nc">Grid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the retinal coordinate frame&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Grid.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">),</span> <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">),</span>
                 <span class="n">eye</span><span class="o">=</span><span class="s1">&#39;RE&#39;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">n_axons</span><span class="o">=</span><span class="mi">501</span><span class="p">,</span> <span class="n">phi_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">),</span>
                 <span class="n">n_rho</span><span class="o">=</span><span class="mi">801</span><span class="p">,</span> <span class="n">rho_range</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">45.0</span><span class="p">),</span> <span class="n">loc_od</span><span class="o">=</span><span class="p">(</span><span class="mf">15.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
                 <span class="n">sensitivity_rule</span><span class="o">=</span><span class="s1">&#39;decay&#39;</span><span class="p">,</span> <span class="n">contribution_rule</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
                 <span class="n">decay_const</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">powermean_exp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datapath</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
                 <span class="n">save_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;joblib&#39;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a spatial grid representing the retinal coordinate frame</span>

<span class="sd">        This function generates the coordinate system for the retina</span>
<span class="sd">        and an axon map. As this can take a while, the function will</span>
<span class="sd">        first look for an already existing file in the directory `datapath`</span>
<span class="sd">        that was automatically created from an earlier call to this function,</span>
<span class="sd">        before it attempts to generate new grid from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_range : (xlo, xhi), optional, default: xlo=-1000, xhi=1000</span>
<span class="sd">           Extent of the retinal coverage (microns) in horizontal dimension.</span>
<span class="sd">        y_range : (ylo, yhi), optional, default: ylo=-1000, ylo=1000</span>
<span class="sd">           Extent of the retinal coverage (microns) in vertical dimension.</span>
<span class="sd">        eye : {&#39;LE&#39;, &#39;RE&#39;}, optional, default: &#39;RE&#39;</span>
<span class="sd">            Which eye to simulate (left/right). The optic disc is at (15, 2)</span>
<span class="sd">            deg in a right eye, and at (-15, 2) deg in a left eye.</span>
<span class="sd">        sampling : float, optional, default: 25</span>
<span class="sd">            Spatial sampling step (microns) for the grid.</span>
<span class="sd">        n_axons : int, optional, default: 501</span>
<span class="sd">            The number of axons to generate. Their start orientations `phi0`</span>
<span class="sd">            (in modified polar coordinates) will be sampled uniformly from</span>
<span class="sd">            `phi_range`.</span>
<span class="sd">        phi_range : (lophi, hiphi), optional, default: (-180, 180)</span>
<span class="sd">            Range of angular positions of axon fibers at their starting points</span>
<span class="sd">            (polar coordinates, degrees) to be sampled uniformly with `n_axons`</span>
<span class="sd">            samples. Must be within [-180, 180].</span>
<span class="sd">        n_rho: int, optional, default: 801</span>
<span class="sd">            Number of sampling points along the radial axis(polar coordinates).</span>
<span class="sd">        rho_range: (rho_min, rho_max), optional, default: (4.0, 45.0)</span>
<span class="sd">            Lower and upper bounds for the radial position values(polar</span>
<span class="sd">            coordinates).</span>
<span class="sd">        loc_od: (x_od, y_od), optional, default: (15.0, 2.0)</span>
<span class="sd">            Location of the center of the optic disc(x, y) in Cartesian</span>
<span class="sd">            coordinates.</span>
<span class="sd">        sensitivity_rule : {&#39;decay&#39;, &#39;Jeng2011&#39;}, optional, default: &#39;decay&#39;</span>
<span class="sd">            This rule specifies how the activation of the axon differs as a</span>
<span class="sd">            function of distance from the soma. The following options are</span>
<span class="sd">            available:</span>
<span class="sd">            - &#39;decay&#39;:</span>
<span class="sd">                Axon sensitivity decays exponentially with distance. Specify</span>
<span class="sd">                `decay_const` to change the steepness of the fall-off with</span>
<span class="sd">                distance.</span>
<span class="sd">            - &#39;Jeng2011&#39;:</span>
<span class="sd">                Axon sensitivity peaks near the sodium band (50um from the</span>
<span class="sd">                soma), then plateaus on the distal axon at roughly half of the</span>
<span class="sd">                peak sensitivity. See Figure 2 in Jeng, Tang, Molnar, Desai,</span>
<span class="sd">                and Fried (2011). The sodium channel band shapes the response</span>
<span class="sd">                to electric stimulation in retinal ganglion cells. J Neural Eng</span>
<span class="sd">                8 (036022).</span>
<span class="sd">        contribution_rule : {&#39;max&#39;, &#39;sum&#39;, &#39;mean&#39;}, optional, default: &#39;max&#39;</span>
<span class="sd">            This rule specifies how the activation thresholds across all axon</span>
<span class="sd">            segments are combined to determine the contribution of the axon to</span>
<span class="sd">            the current spread. The following options are available:</span>
<span class="sd">            - &#39;max&#39;:</span>
<span class="sd">                The axon&#39;s contribution to the current spread is equal to the</span>
<span class="sd">                max. sensitivity across all axon segments.</span>
<span class="sd">            - &#39;sum&#39;:</span>
<span class="sd">                The axon&#39;s contribution to the current spread is equal to the</span>
<span class="sd">                sum sensitivity across all axon segments.</span>
<span class="sd">            - &#39;mean&#39;:</span>
<span class="sd">                The axon&#39;s contribution to the current spread is equal to the</span>
<span class="sd">                mean sensitivity across all axon segments. Specify</span>
<span class="sd">                `powermean_exp` to change the exponent of the generalized</span>
<span class="sd">                (power) mean, calculated as np.mean(x ** powermean_exp) **</span>
<span class="sd">                (1.0 / powermean_exp).</span>
<span class="sd">        decay_const : float, optional, default: 2.0</span>
<span class="sd">            When `sensitivity_rule` is set to &#39;decay&#39;, specifies the decay</span>
<span class="sd">            constant of the exponential fall-off.</span>
<span class="sd">        powermean_exp : float, optional, default: None</span>
<span class="sd">            When `sensitivity_rule` is set to &#39;mean&#39;, specifies the exponent of</span>
<span class="sd">            the generalized (power) mean function. The power mean is calculated</span>
<span class="sd">            as np.mean(x ** powermean_exp) ** (1.0 / powermean_exp).</span>
<span class="sd">        datapath : str, optional, default: current directory</span>
<span class="sd">            Relative path where to look for existing retina files, and where to</span>
<span class="sd">            store new files.</span>
<span class="sd">        save_data : bool, optional, default: True</span>
<span class="sd">            Flag whether to save the data to a new file (True) or not (False).</span>
<span class="sd">            The file name is automatically generated from all specified input</span>
<span class="sd">            arguments.</span>
<span class="sd">        engine : str, optional, default: &#39;joblib&#39;</span>
<span class="sd">            Which computational back end to use:</span>
<span class="sd">            - &#39;serial&#39;: Single-core computation</span>
<span class="sd">            - &#39;joblib&#39;: Parallelization via joblib (requires `pip install</span>
<span class="sd">                        joblib`)</span>
<span class="sd">            - &#39;dask&#39;: Parallelization via dask (requires `pip install dask`).</span>
<span class="sd">                      Dask backend can be specified via `threading`.</span>
<span class="sd">        scheduler : str, optional, default: &#39;threading&#39;</span>
<span class="sd">            Which scheduler to use (irrelevant for &#39;serial&#39; engine):</span>
<span class="sd">            - &#39;threading&#39;: a scheduler backed by a thread pool</span>
<span class="sd">            - &#39;multiprocessing&#39;: a scheduler backed by a process pool</span>
<span class="sd">        n_jobs : int, optional, default: -1</span>
<span class="sd">            Number of cores (threads) to run the model on in parallel.</span>
<span class="sd">            Specify -1 to use as many cores as available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`x_range` must be a tuple (`xlo`, `xhi`).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower bound on x cannot be larger than the &#39;</span>
                             <span class="s1">&#39;upper bound.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_range</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`y_range` must be a tuple (`ylo`, `yhi`).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower bound on y cannot be larger than the &#39;</span>
                             <span class="s1">&#39;upper bound.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_axons</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of axons must be &gt;= 1.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phi_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">180.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;phi must be within [-180, 180].&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phi_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">phi_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower bound on phi cannot be larger than the &#39;</span>
                             <span class="s1">&#39;upper bound.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_range</span> <span class="o">=</span> <span class="n">x_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_range</span> <span class="o">=</span> <span class="n">y_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivity_rule</span> <span class="o">=</span> <span class="n">sensitivity_rule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contribution_rule</span> <span class="o">=</span> <span class="n">contribution_rule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_const</span> <span class="o">=</span> <span class="n">decay_const</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">powermean_exp</span> <span class="o">=</span> <span class="n">powermean_exp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">10.0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The Jansonius model might &quot;</span>
                                             <span class="s2">&quot;misbehave if `loc_od` has &quot;</span>
                                             <span class="s2">&quot;a y value &gt; 10.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eye</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;RE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">w_s</span> <span class="o">=</span> <span class="s2">&quot;In a right eye, the optic disc usually has x &gt; 0 - &quot;</span>
                <span class="n">w_s</span> <span class="o">+=</span> <span class="s2">&quot;currently at (</span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">w_s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">eye</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;LE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">w_s</span> <span class="o">=</span> <span class="s2">&quot;In a left eye, the optic disc usually has x &lt; 0 - &quot;</span>
                <span class="n">w_s</span> <span class="o">+=</span> <span class="s2">&quot;currently at (</span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">w_s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_s</span> <span class="o">=</span> <span class="s2">&quot;Unknown eye string &#39;</span><span class="si">%s</span><span class="s2">&#39;: Choose from &#39;LE&#39;, &#39;RE&#39;.&quot;</span> <span class="o">%</span> <span class="n">eye</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e_s</span><span class="p">)</span>

        <span class="c1"># Include endpoints in meshgrid</span>
        <span class="n">xlo</span><span class="p">,</span> <span class="n">xhi</span> <span class="o">=</span> <span class="n">x_range</span>
        <span class="n">ylo</span><span class="p">,</span> <span class="n">yhi</span> <span class="o">=</span> <span class="n">y_range</span>
        <span class="n">num_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">xhi</span> <span class="o">-</span> <span class="n">xlo</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">num_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">yhi</span> <span class="o">-</span> <span class="n">ylo</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">xhi</span><span class="p">,</span> <span class="n">num_x</span><span class="p">),</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ylo</span><span class="p">,</span> <span class="n">yhi</span><span class="p">,</span> <span class="n">num_y</span><span class="p">),</span>
                                             <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>

        <span class="c1"># Create descriptive filename based on input args</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;retina_</span><span class="si">%s</span><span class="s2">_s</span><span class="si">%d</span><span class="s2">_a</span><span class="si">%d</span><span class="s2">_r</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">x</span><span class="si">%d</span><span class="s2">.npz&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">n_axons</span><span class="p">,</span>
                                                        <span class="n">n_rho</span><span class="p">,</span> <span class="n">xhi</span> <span class="o">-</span> <span class="n">xlo</span><span class="p">,</span>
                                                        <span class="n">yhi</span> <span class="o">-</span> <span class="n">ylo</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># There are some variables, like `sensitivity_rule` and `decay_const`</span>
        <span class="c1"># that are only needed in the effective current calculation, not for</span>
        <span class="c1"># the grid and axon maps - so not included here:</span>
        <span class="n">grid_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x_range&#39;</span><span class="p">:</span> <span class="n">x_range</span><span class="p">,</span> <span class="s1">&#39;y_range&#39;</span><span class="p">:</span> <span class="n">y_range</span><span class="p">,</span> <span class="s1">&#39;eye&#39;</span><span class="p">:</span> <span class="n">eye</span><span class="p">,</span>
                     <span class="s1">&#39;n_axons&#39;</span><span class="p">:</span> <span class="n">n_axons</span><span class="p">,</span> <span class="s1">&#39;phi_range&#39;</span><span class="p">:</span> <span class="n">phi_range</span><span class="p">,</span>
                     <span class="s1">&#39;n_rho&#39;</span><span class="p">:</span> <span class="n">n_rho</span><span class="p">,</span> <span class="s1">&#39;rho_range&#39;</span><span class="p">:</span> <span class="n">rho_range</span><span class="p">,</span>
                     <span class="s1">&#39;sampling&#39;</span><span class="p">:</span> <span class="n">sampling</span><span class="p">,</span> <span class="s1">&#39;loc_od&#39;</span><span class="p">:</span> <span class="n">loc_od</span><span class="p">}</span>

        <span class="c1"># Assign all elements in the dictionary to this object</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Check if such a file already exists. If so, load parameters and</span>
        <span class="c1"># make sure they are the same as specified above. Else, create new.</span>
        <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Loading file &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">load_grid_dict</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">cPickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;UnpicklingError: Could not load file &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">load_grid_dict</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Make sure all relevant variables are present and have the right</span>
            <span class="c1"># values:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">load_grid_dict</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;File out of date.&#39;</span><span class="p">)</span>
                    <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">load_grid_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;File out of date.&#39;</span><span class="p">)</span>
                    <span class="n">need_new_grid</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

        <span class="c1"># At this point we know whether we need to generate a new retina:</span>
        <span class="k">if</span> <span class="n">need_new_grid</span><span class="p">:</span>
            <span class="n">info_str</span> <span class="o">=</span> <span class="s2">&quot;Generating new file &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">filename</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info_str</span><span class="p">)</span>

            <span class="c1"># Grow a number `n_axons` of axon bundles with orientations in</span>
            <span class="c1"># `phi_range`</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">phi_range</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_axons</span><span class="p">)</span>
            <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_rho&#39;</span><span class="p">:</span> <span class="n">n_rho</span><span class="p">,</span> <span class="s1">&#39;rho_range&#39;</span><span class="p">:</span> <span class="n">rho_range</span><span class="p">,</span>
                           <span class="s1">&#39;loc_od&#39;</span><span class="p">:</span> <span class="n">loc_od</span><span class="p">,</span> <span class="s1">&#39;eye&#39;</span><span class="p">:</span> <span class="n">eye</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axon_bundles</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parfor</span><span class="p">(</span><span class="n">jansonius2009</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                                             <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span>
                                             <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                             <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">)</span>
            <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;axon_bundles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_bundles</span>

            <span class="c1"># Assume there is a neuron at every grid location: Use the above</span>
            <span class="c1"># axon bundles to assign an axon to each neuron</span>
            <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">ret2dva</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">),</span> <span class="n">ret2dva</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">)</span>
            <span class="n">pos_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axons</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parfor</span><span class="p">(</span><span class="n">find_closest_axon</span><span class="p">,</span> <span class="n">pos_xy</span><span class="p">,</span>
                                      <span class="n">func_args</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axon_bundles</span><span class="p">])</span>
            <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;axons&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axons</span>

            <span class="c1"># For every axon segment, calculate distance to soma. Snap axon</span>
            <span class="c1"># locations to the grid using a nearest-neighbor tree structure:</span>
            <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tree&#39;</span><span class="p">:</span> <span class="n">spat</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">pos_xy</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axon_distances</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parfor</span><span class="p">(</span><span class="n">axon_dist_from_soma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axons</span><span class="p">,</span>
                                               <span class="n">func_args</span><span class="o">=</span><span class="p">[</span><span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">],</span>
                                               <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span>
                                               <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                               <span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">)</span>
            <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;axon_distances&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_distances</span>

            <span class="c1"># Save the variables, together with metadata about the grid:</span>
            <span class="k">if</span> <span class="n">save_data</span><span class="p">:</span>
                <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assign all elements in the loaded dictionary to this object</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">load_grid_dict</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Grid.current2effectivecurrent"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.current2effectivecurrent">[docs]</a>    <span class="k">def</span> <span class="nf">current2effectivecurrent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_spread</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts a current spread map to an &#39;effective&#39; current spread map, by</span>
<span class="sd">        passing the map through a mapping of axon streaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs: array</span>
<span class="sd">            The 2D spread map in retinal space</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ecm: array</span>
<span class="sd">            The effective current spread, a time series of the same size as</span>
<span class="sd">            the current map, where each pixel is the dot product of the pixel</span>
<span class="sd">            values in ecm along the pixels in the list in axon_map, weighted</span>
<span class="sd">            by the weights axon map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contrib</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parfor</span><span class="p">(</span><span class="n">axon_contribution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_distances</span><span class="p">,</span>
                               <span class="n">func_args</span><span class="o">=</span><span class="p">[</span><span class="n">current_spread</span><span class="p">],</span> <span class="n">engine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span>
                               <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span>
                                   <span class="s1">&#39;sensitivity_rule&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensitivity_rule</span><span class="p">,</span>
                                   <span class="s1">&#39;contribution_rule&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">contribution_rule</span><span class="p">,</span>
                                   <span class="s1">&#39;decay_const&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_const</span><span class="p">,</span>
                                   <span class="s1">&#39;powermean_exp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">powermean_exp</span>
                               <span class="p">},</span>
                               <span class="n">scheduler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>

        <span class="n">ecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_spread</span><span class="p">)</span>
        <span class="n">px_contrib</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">contrib</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">px_contrib</span><span class="p">:</span>
            <span class="n">ecs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Normalize so that the max of `ecs` is the same as `current_spread`</span>
        <span class="k">return</span> <span class="n">ecs</span> <span class="o">/</span> <span class="p">(</span><span class="n">ecs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="n">current_spread</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>

<div class="viewcode-block" id="Grid.electrode_ecs"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Grid.electrode_ecs">[docs]</a>    <span class="k">def</span> <span class="nf">electrode_ecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">implant</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">14000</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mf">1.69</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gather current spread and effective current spread for each electrode</span>
<span class="sd">        within both the bipolar and the ganglion cell layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        implant: implants.ElectrodeArray</span>
<span class="sd">            An implants.ElectrodeArray instance describing the implant.</span>

<span class="sd">        alpha: float</span>
<span class="sd">            Current spread parameter</span>
<span class="sd">        n: float</span>
<span class="sd">            Current spread parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ecs: contains n arrays containing the the effective current</span>
<span class="sd">            spread within various layers</span>
<span class="sd">            for each electrode in the array respectively.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Electrode.current_spread</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                       <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">)))</span>
        <span class="n">ecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">implant</span><span class="o">.</span><span class="n">electrodes</span><span class="p">):</span>
            <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">current_spread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">,</span>
                                             <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;INL&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ecs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">current_spread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridy</span><span class="p">,</span>
                                             <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;OFL&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ecs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current2effectivecurrent</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ecs</span><span class="p">,</span> <span class="n">cs</span></div></div>


<div class="viewcode-block" id="BaseModel"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BaseModel</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for all models of temporal sensitivity.</span>

<span class="sd">    This class provides a standard template for all models of temporal</span>
<span class="sd">    sensitivity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BaseModel.set_kwargs"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.set_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">set_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warn_inexistent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrite any given keyword arguments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        warn_inexistent: bool</span>
<span class="sd">            If True, displays a warning message if a keyword is provided that</span>
<span class="sd">            is not recognized by the temporal model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">warn_inexistent</span><span class="p">:</span>
                <span class="n">w_s</span> <span class="o">=</span> <span class="s2">&quot;Unknown class attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">w_s</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseModel.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseModel.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.BaseModel.model_cascade">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract base ganglion cell model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array - like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location(pixel); one value per retinal layer and</span>
<span class="sd">            electrode. Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        use_jit: bool</span>
<span class="sd">            If True, applies just - in-time(JIT) compilation to expensive</span>
<span class="sd">            computations for additional speed - up(requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="c1"># Static attribute</span>
    <span class="n">tsample</span> <span class="o">=</span> <span class="mf">0.005</span> <span class="o">/</span> <span class="mi">1000</span></div>


<div class="viewcode-block" id="Horsager2009"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009">[docs]</a><span class="k">class</span> <span class="nc">Horsager2009</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Model of temporal sensitivity (Horsager et al. 2009)</span>

<span class="sd">    This class implements the model of temporal sensitivty as described in:</span>
<span class="sd">    &gt; A Horsager, SH Greenwald, JD Weiland, MS Humayun, RJ Greenberg,</span>
<span class="sd">    &gt; MJ McMahon, GM Boynton, and I Fine(2009). Predicting visual sensitivity</span>
<span class="sd">    &gt; in retinal prosthesis patients. Investigative Ophthalmology &amp; Visual</span>
<span class="sd">    &gt; Science, 50(4): 1483.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample: float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step(seconds).</span>
<span class="sd">    tau1: float, optional, default: 0.42 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer(GCL).</span>
<span class="sd">    tau2: float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    tau3: float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">        Default: 26.25 / 1000 s.</span>
<span class="sd">    epsilon: float, optional, default: 8.73</span>
<span class="sd">        Scaling factor applied to charge accumulation(used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    beta: float, optional, default: 3.43</span>
<span class="sd">        Power nonlinearity applied after half - rectification. The original model</span>
<span class="sd">        used two different values, depending on whether an experiment is at</span>
<span class="sd">        threshold(`beta`=3.43) or above threshold(`beta`=0.83).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Horsager2009.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">2.25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="mf">3.43</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="Horsager2009.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the effective current map of a given layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array - like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location(pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Horsager2009 model does not support an &quot;</span>
                             <span class="s2">&quot;inner nuclear layer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` are: &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;OFL&#39;.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="Horsager2009.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Horsager2009.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Horsager model cascade</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array - like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location(pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        use_jit: bool</span>
<span class="sd">            If True, applies just - in-time(JIT) compilation to</span>
<span class="sd">            expensive computations for additional speed - up</span>
<span class="sd">            (requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="c1"># Although the paper says to use cathodic-first, the code only</span>
        <span class="c1"># reproduces if we use what we now call anodic-first. So flip the sign</span>
        <span class="c1"># on the stimulus here:</span>
        <span class="n">stim</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># R1 convolved the entire stimulus (with both pos + neg parts)</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="c1"># It&#39;s possible that charge accumulation was done on the anodic phase.</span>
        <span class="c1"># It might not matter too much (timing is slightly different, but the</span>
        <span class="c1"># data are not accurate enough to warrant using one over the other).</span>
        <span class="c1"># Thus use what makes the most sense: accumulate on cathodic</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">stim</span><span class="p">))</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">ca</span>

        <span class="c1"># Then half-rectify and pass through the power-nonlinearity</span>
        <span class="n">r3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

        <span class="c1"># Then convolve with slow gamma</span>
        <span class="n">r4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">r3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">stim</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">r4</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Nanduri2012"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012">[docs]</a><span class="k">class</span> <span class="nc">Nanduri2012</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Model of temporal sensitivity (Nanduri et al. 2012)</span>

<span class="sd">    This class implements the model of temporal sensitivity as described in:</span>
<span class="sd">    &gt; Nanduri, Fine, Horsager, Boynton, Humayun, Greenberg, Weiland(2012).</span>
<span class="sd">    &gt; Frequency and Amplitude Modulation Have Different Effects on the Percepts</span>
<span class="sd">    &gt; Elicited by Retinal Stimulation. Investigative Ophthalmology &amp; Visual</span>
<span class="sd">    &gt; Science January 2012, Vol.53, 205 - 214. doi: 10.1167 / iovs.11 - 8401.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample: float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step(seconds).</span>
<span class="sd">    tau1: float, optional, default: 0.42 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer(GCL).</span>
<span class="sd">    tau2: float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    tau3: float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">        Default: 26.25 / 1000 s.</span>
<span class="sd">    eps: float, optional, default: 8.73</span>
<span class="sd">        Scaling factor applied to charge accumulation(used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    asymptote: float, optional, default: 14.0</span>
<span class="sd">        Asymptote of the logistic function used in the stationary</span>
<span class="sd">        nonlinearity stage.</span>
<span class="sd">    slope: float, optional, default: 3.0</span>
<span class="sd">        Slope of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    shift: float, optional, default: 16.0</span>
<span class="sd">        Shift of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Nanduri2012.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Set default values of keyword arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">8.73</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span> <span class="o">=</span> <span class="mf">14.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mf">16.0</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># perform one-time setup calculations</span>
        <span class="c1"># gamma1 is used for the fast response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma2 is used to calculate charge accumulation</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma3 is used to calculate the slow response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="Nanduri2012.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the effective current map of a given layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array - like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location(pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span><span class="p">,</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)]):</span>
            <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` are: &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;OFL&#39;.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="Nanduri2012.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.Nanduri2012.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Nanduri model cascade</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_arr: array - like</span>
<span class="sd">            A 2D array specifying the effective current values</span>
<span class="sd">            at a particular spatial location(pixel); one value</span>
<span class="sd">            per retinal layer and electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            List of pulse train &#39;data&#39; containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate.</span>
<span class="sd">            Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">        use_jit: bool</span>
<span class="sd">            If True, applies just - in-time(JIT) compilation to</span>
<span class="sd">            expensive computations for additional speed - up</span>
<span class="sd">            (requires Numba).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Nanduri2012 model does not support an inner &quot;</span>
                             <span class="s2">&quot;nuclear layer.&quot;</span><span class="p">)</span>

        <span class="c1"># Although the paper says to use cathodic-first, the code only</span>
        <span class="c1"># reproduces if we use what we now call anodic-first. So flip the sign</span>
        <span class="c1"># on the stimulus here:</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">in_arr</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># Fast response</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">,</span>
                                       <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="c1"># Charge accumulation</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">ca</span><span class="p">)</span>

        <span class="c1"># Stationary nonlinearity</span>
        <span class="n">b3max</span> <span class="o">=</span> <span class="n">b3</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">sigmoid</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expit</span><span class="p">((</span><span class="n">b3max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
        <span class="n">b4</span> <span class="o">=</span> <span class="n">b3</span> <span class="o">/</span> <span class="n">b3max</span> <span class="o">*</span> <span class="n">sigmoid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">asymptote</span>

        <span class="c1"># Slow response</span>
        <span class="n">b5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">b4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)[:</span><span class="n">b1</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">b5</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TemporalModel"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel">[docs]</a><span class="k">class</span> <span class="nc">TemporalModel</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Latest edition of the temporal sensitivity model (experimental)</span>

<span class="sd">    This class implements the latest version of the temporal sensitivity</span>
<span class="sd">    model(experimental). As such, the model might still change from version</span>
<span class="sd">    to version. For more stable implementations, please refer to other,</span>
<span class="sd">    published models(see `p2p.retina.SUPPORTED_TEMPORAL_MODELS`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tsample: float, optional, default: 0.005 / 1000 seconds</span>
<span class="sd">        Sampling time step(seconds).</span>
<span class="sd">    tau_gcl: float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the ganglion</span>
<span class="sd">        cell layer(GCL).</span>
<span class="sd">        This is only important in combination with epiretinal electrode</span>
<span class="sd">        arrays.</span>
<span class="sd">    tau_inl: float, optional, default: 18.0 / 1000 seconds</span>
<span class="sd">        Time decay constant for the fast leaky integrater of the inner</span>
<span class="sd">        nuclear layer(INL); i.e., bipolar cell layer.</span>
<span class="sd">        This is only important in combination with subretinal electrode</span>
<span class="sd">        arrays.</span>
<span class="sd">    tau_ca: float, optional, default: 45.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the charge accumulation, has values</span>
<span class="sd">        between 38 - 57 ms.</span>
<span class="sd">    scale_ca: float, optional, default: 42.1</span>
<span class="sd">        Scaling factor applied to charge accumulation(used to be called</span>
<span class="sd">        epsilon).</span>
<span class="sd">    tau_slow: float, optional, default: 26.25 / 1000 seconds</span>
<span class="sd">        Time decay constant for the slow leaky integrator.</span>
<span class="sd">    scale_slow: float, optional, default: 1150.0</span>
<span class="sd">        Scaling factor applied to the output of the cascade, to make</span>
<span class="sd">        output values interpretable brightness values &gt;= 0.</span>
<span class="sd">    lweight: float, optional, default: 0.636</span>
<span class="sd">        Relative weight applied to responses from bipolar cells(weight</span>
<span class="sd">        of ganglion cells is 1).</span>
<span class="sd">    aweight: float, optional, default: 0.5</span>
<span class="sd">        Relative weight applied to anodic charges(weight of cathodic</span>
<span class="sd">        charges is 1).</span>
<span class="sd">    slope: float, optional, default: 3.0</span>
<span class="sd">        Slope of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    shift: float, optional, default: 15.0</span>
<span class="sd">        Shift of the logistic function in the stationary nonlinearity</span>
<span class="sd">        stage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TemporalModel.__init__"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Set default values of keyword arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_gcl</span> <span class="o">=</span> <span class="mf">0.42</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_inl</span> <span class="o">=</span> <span class="mf">18.0</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_ca</span> <span class="o">=</span> <span class="mf">45.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_slow</span> <span class="o">=</span> <span class="mf">26.25</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_ca</span> <span class="o">=</span> <span class="mf">42.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_slow</span> <span class="o">=</span> <span class="mf">1150.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lweight</span> <span class="o">=</span> <span class="mf">0.636</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="mf">15.0</span>

        <span class="c1"># Overwrite any given keyword arguments, print warning message (True)</span>
        <span class="c1"># if attempting to set an unrecognized keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kwargs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># perform one-time setup calculations</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_inl</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_inl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_gcl</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_gcl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma_ca is used to calculate charge accumulation</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_ca</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_ca</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span>

        <span class="c1"># gamma_slow is used to calculate the slow response</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_slow</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_slow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">)</span></div>

<div class="viewcode-block" id="TemporalModel.fast_response"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.fast_response">[docs]</a>    <span class="k">def</span> <span class="nf">fast_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">use_jit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fast response function</span>

<span class="sd">        Convolve a stimulus `stim` with a temporal low - pass filter `gamma`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim: array</span>
<span class="sd">           Temporal signal to process, stim(r, t) in Nanduri et al. (2012).</span>
<span class="sd">        use_jit: bool, optional</span>
<span class="sd">           If True (default), use numba just - in-time compilation.</span>
<span class="sd">        usefft: bool, optional</span>
<span class="sd">           If False (default), use sparseconv, else fftconvolve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Fast response, b2(r, t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function utils.sparseconv can be much faster than np.convolve and</span>
<span class="sd">        signal.fftconvolve if `stim` is sparse and much longer than the</span>
<span class="sd">        convolution kernel.</span>
<span class="sd">        The output is not converted to a TimeSeries object for speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                          <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">)</span>

        <span class="c1"># Cut off the tail of the convolution to make the output signal</span>
        <span class="c1"># match the dimensions of the input signal.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">conv</span><span class="p">[:</span><span class="n">stim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TemporalModel.charge_accumulation"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.charge_accumulation">[docs]</a>    <span class="k">def</span> <span class="nf">charge_accumulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the charge accumulation</span>

<span class="sd">        Charge accumulation is calculated on the effective input current</span>
<span class="sd">        `ecm`, as opposed to the output of the fast response stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecm: array - like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location(pixel); one value per retinal layer, averaged</span>
<span class="sd">            over all electrodes through that pixel.</span>
<span class="sd">            Dimensions: &lt;  # layers x #time points&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">summed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="n">conved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">summed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_ca</span><span class="p">,</span>
                                               <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">)</span>
            <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_ca</span> <span class="o">*</span> <span class="n">conved</span><span class="p">[:</span><span class="n">ecm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ca</span></div>

<div class="viewcode-block" id="TemporalModel.stationary_nonlinearity"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.stationary_nonlinearity">[docs]</a>    <span class="k">def</span> <span class="nf">stationary_nonlinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stationary nonlinearity</span>

<span class="sd">        Nonlinearly rescale a temporal signal `stim` across space and time,</span>
<span class="sd">        based on a sigmoidal function dependent on the maximum value of `stim`.</span>
<span class="sd">        This is Box 4 in Nanduri et al. (2012).</span>
<span class="sd">        The parameter values of the asymptote, slope, and shift of the logistic</span>
<span class="sd">        function are given by self.asymptote, self.slope, and self.shift,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim: array</span>
<span class="sd">           Temporal signal to process, stim(r, t) in Nanduri et al. (2012).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rescaled signal, b4(r, t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Conversion to TimeSeries is avoided for the sake of speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use expit (logistic) function for speedup</span>
        <span class="n">sigmoid</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expit</span><span class="p">((</span><span class="n">stim</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stim</span> <span class="o">*</span> <span class="n">sigmoid</span></div>

<div class="viewcode-block" id="TemporalModel.slow_response"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.slow_response">[docs]</a>    <span class="k">def</span> <span class="nf">slow_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slow response function</span>

<span class="sd">        Convolve a stimulus `stim` with a low - pass filter(3 - stage gamma)</span>
<span class="sd">        with time constant self.tau_slow.</span>
<span class="sd">        This is Box 5 in Nanduri et al. (2012).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stim: array</span>
<span class="sd">           Temporal signal to process, stim(r, t) in Nanduri et al. (2012)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Slow response, b5(r, t) in Nanduri et al. (2012).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is by far the most computationally involved part of the perceptual</span>
<span class="sd">        sensitivity model.</span>
<span class="sd">        Conversion to TimeSeries is avoided for the sake of speedup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No need to zero-pad: fftconvolve already takes care of optimal</span>
        <span class="c1"># kernel/data size</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">stim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_slow</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>

        <span class="c1"># Cut off the tail of the convolution to make the output signal match</span>
        <span class="c1"># the dimensions of the input signal.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_slow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsample</span> <span class="o">*</span> <span class="n">conv</span><span class="p">[:</span><span class="n">stim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TemporalModel.calc_layer_current"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.calc_layer_current">[docs]</a>    <span class="k">def</span> <span class="nf">calc_layer_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a given pixel, calculates the effective current for each retinal</span>
<span class="sd">           layer over time</span>

<span class="sd">        This function operates at a single - pixel level: It calculates the</span>
<span class="sd">        combined current from all electrodes through a spatial location</span>
<span class="sd">        over time. This calculation is performed per retinal layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecs_item: array - like</span>
<span class="sd">            A 2D array specifying the effective current values at a</span>
<span class="sd">            particular spatial location(pixel); one value per retinal</span>
<span class="sd">            layer and electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            A list of PulseTrain `data` containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate. Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">not_supported</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_LAYERS</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">],</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">not_supported</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable values for `layers` is &#39;OFL&#39;, &#39;GCL&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;INL&#39;.&quot;</span><span class="p">)</span>

        <span class="n">ecm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ecs_item</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ecm</span></div>

<div class="viewcode-block" id="TemporalModel.model_cascade"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.TemporalModel.model_cascade">[docs]</a>    <span class="k">def</span> <span class="nf">model_cascade</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">use_jit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Temporal Sensitivity model</span>

<span class="sd">        This function applies the model of temporal sensitivity to a single</span>
<span class="sd">        retinal cell(i.e., a pixel). The model is inspired by Nanduri</span>
<span class="sd">        et al. (2012), with some extended functionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ecs_item: array - like</span>
<span class="sd">            A 2D array specifying the effective current values at a particular</span>
<span class="sd">            spatial location(pixel); one value per retinal layer and</span>
<span class="sd">            electrode.</span>
<span class="sd">            Dimensions: &lt;  # layers x #electrodes&gt;</span>
<span class="sd">        pt_list: list</span>
<span class="sd">            A list of PulseTrain `data` containers.</span>
<span class="sd">            Dimensions: &lt;  # electrodes x #time points&gt;</span>
<span class="sd">        layers: list</span>
<span class="sd">            List of retinal layers to simulate. Choose from:</span>
<span class="sd">            - &#39;OFL&#39;: optic fiber layer</span>
<span class="sd">            - &#39;GCL&#39;: ganglion cell layer</span>
<span class="sd">            - &#39;INL&#39;: inner nuclear layer</span>
<span class="sd">        use_jit: bool</span>
<span class="sd">            If True, applies just - in-time(JIT) compilation to expensive</span>
<span class="sd">            computations for additional speed - up(requires Numba).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Brightness response over time. In Nanduri et al. (2012), the</span>
<span class="sd">        maximum value of this signal was used to represent the perceptual</span>
<span class="sd">        brightness of a particular location in space, B(r).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each layer in the model, scale the pulse train data with the</span>
        <span class="c1"># effective current:</span>
        <span class="n">ecm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_layer_current</span><span class="p">(</span><span class="n">ecs_item</span><span class="p">,</span> <span class="n">pt_list</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>

        <span class="c1"># Calculate charge accumulation on the input</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_accumulation</span><span class="p">(</span><span class="n">ecm</span><span class="p">)</span>

        <span class="c1"># Sparse convolution is faster if input is sparse. This is true for</span>
        <span class="c1"># the first convolution in the cascade, but not for subsequent ones.</span>
        <span class="k">if</span> <span class="s1">&#39;INL&#39;</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">fr_inl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_response</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_inl</span><span class="p">,</span>
                                        <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)</span>

            <span class="c1"># Cathodic and anodic parts are treated separately: They have the</span>
            <span class="c1"># same charge accumulation, but anodic currents contribute less to</span>
            <span class="c1"># the response</span>
            <span class="n">fr_inl_cath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fr_inl</span><span class="p">)</span>
            <span class="n">fr_inl_anod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_inl</span><span class="p">)</span>
            <span class="n">resp_inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_inl_cath</span> <span class="o">+</span> <span class="n">fr_inl_anod</span> <span class="o">-</span> <span class="n">ca</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resp_inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;GCL&#39;</span> <span class="ow">or</span> <span class="s1">&#39;OFL&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">fr_gcl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_response</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_gcl</span><span class="p">,</span>
                                        <span class="n">use_jit</span><span class="o">=</span><span class="n">use_jit</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;sparse&#39;</span><span class="p">)</span>

            <span class="c1"># Cathodic and anodic parts are treated separately: They have the</span>
            <span class="c1"># same charge accumulation, but anodic currents contribute less to</span>
            <span class="c1"># the response</span>
            <span class="n">fr_gcl_cath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">fr_gcl</span><span class="p">)</span>
            <span class="n">fr_gcl_anod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aweight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_gcl</span><span class="p">)</span>
            <span class="n">resp_gcl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fr_gcl_cath</span> <span class="o">+</span> <span class="n">fr_gcl_anod</span> <span class="o">-</span> <span class="n">ca</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resp_gcl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ecm</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">resp</span> <span class="o">=</span> <span class="n">resp_gcl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lweight</span> <span class="o">*</span> <span class="n">resp_inl</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stationary_nonlinearity</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_response</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsample</span><span class="p">,</span> <span class="n">resp</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ret2dva"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.ret2dva">[docs]</a><span class="k">def</span> <span class="nf">ret2dva</span><span class="p">(</span><span class="n">r_um</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts retinal distances (um) to visual angles (deg)</span>

<span class="sd">    This function converts an eccentricity measurement on the retinal</span>
<span class="sd">    surface(in micrometers), measured from the optic axis, into degrees</span>
<span class="sd">    of visual angle.</span>
<span class="sd">    Source: Eq. A6 in Watson(2014), J Vis 14(7): 15, 1 - 17</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">r_um</span><span class="p">)</span>
    <span class="n">r_mm</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r_um</span><span class="p">)</span>
    <span class="n">r_deg</span> <span class="o">=</span> <span class="mf">3.556</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">+</span> <span class="mf">0.05993</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.007358</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">r_deg</span> <span class="o">+=</span> <span class="mf">3.027e-4</span> <span class="o">*</span> <span class="n">r_mm</span> <span class="o">**</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">r_deg</span></div>


<div class="viewcode-block" id="dva2ret"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.dva2ret">[docs]</a><span class="k">def</span> <span class="nf">dva2ret</span><span class="p">(</span><span class="n">r_deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts visual angles (deg) into retinal distances (um)</span>

<span class="sd">    This function converts a retinal distancefrom the optic axis(um)</span>
<span class="sd">    into degrees of visual angle.</span>
<span class="sd">    Source: Eq. A5 in Watson(2014), J Vis 14(7): 15, 1 - 17</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">r_deg</span><span class="p">)</span>
    <span class="n">r_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r_deg</span><span class="p">)</span>
    <span class="n">r_mm</span> <span class="o">=</span> <span class="mf">0.268</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">+</span> <span class="mf">3.427e-4</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">8.3309e-6</span> <span class="o">*</span> <span class="n">r_deg</span> <span class="o">**</span> <span class="mi">3</span>
    <span class="n">r_um</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="o">*</span> <span class="n">r_mm</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">r_um</span></div>


<div class="viewcode-block" id="jansonius2009"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.jansonius2009">[docs]</a><span class="k">def</span> <span class="nf">jansonius2009</span><span class="p">(</span><span class="n">phi0</span><span class="p">,</span> <span class="n">n_rho</span><span class="o">=</span><span class="mi">801</span><span class="p">,</span> <span class="n">rho_range</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">45.0</span><span class="p">),</span> <span class="n">eye</span><span class="o">=</span><span class="s1">&#39;RE&#39;</span><span class="p">,</span>
                  <span class="n">loc_od</span><span class="o">=</span><span class="p">(</span><span class="mf">15.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">beta_sup</span><span class="o">=-</span><span class="mf">1.9</span><span class="p">,</span> <span class="n">beta_inf</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Grows a single axon bundle based on the model by Jansonius et al. (2009)</span>

<span class="sd">    This function generates the trajectory of a single nerve fiber bundle</span>
<span class="sd">    based on the mathematical model described in [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi0: float</span>
<span class="sd">        Angular position of the axon at its starting point(polar</span>
<span class="sd">        coordinates, degrees). Must be within[-180, 180].</span>
<span class="sd">    n_rho: int, optional, default: 801</span>
<span class="sd">        Number of sampling points along the radial axis(polar coordinates).</span>
<span class="sd">    rho_range: (rho_min, rho_max), optional, default: (4.0, 45.0)</span>
<span class="sd">        Lower and upper bounds for the radial position values(polar</span>
<span class="sd">        coordinates).</span>
<span class="sd">    loc_od: (x_od, y_od), optional, default: (15.5, 1.5)</span>
<span class="sd">        Location of the center of the optic disc(x, y) in Cartesian</span>
<span class="sd">        coordinates. In a right (left) eye, we should have x &gt; 0 (x &lt; 0).</span>
<span class="sd">    beta_sup: float, optional, default: -1.9</span>
<span class="sd">        Scalar value for the superior retina(see Eq. 5, `\beta_s` in the</span>
<span class="sd">        paper).</span>
<span class="sd">    beta_inf: float, optional, default: 0.5</span>
<span class="sd">        Scalar value for the inferior retina(see Eq. 6, `\beta_i` in the</span>
<span class="sd">        paper.)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax_pos: Nx2 array</span>
<span class="sd">        Returns a two - dimensional array of axonal positions, where</span>
<span class="sd">        ax_pos[0, :] contains the(x, y) coordinates of the axon segment closest</span>
<span class="sd">        to the optic disc, and aubsequent row indices move the axon away from</span>
<span class="sd">        the optic disc. Number of rows is at most `n_rho`, but might be smaller</span>
<span class="sd">        if the axon crosses the meridian.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The study did not include axons with phi0 in [-60, 60] deg.</span>

<span class="sd">    .. [1] N. M. Jansionus, J. Nevalainen, B. Selig, L.M. Zangwill, P.A.</span>
<span class="sd">           Sample, W. M. Budde, J. B. Jonas, W. A. Lagrèze, P. J. Airaksinen,</span>
<span class="sd">           R. Vonthein, L. A. Levin, J. Paetzold, and U. Schieferd, &quot;A</span>
<span class="sd">           mathematical description of nerve fiber bundle trajectories and</span>
<span class="sd">           their variability in the human retina. Vision Research 49:2157-2163,</span>
<span class="sd">           2009.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">eye</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;LE&#39;</span><span class="p">,</span> <span class="s1">&#39;RE&#39;</span><span class="p">]:</span>
        <span class="n">e_s</span> <span class="o">=</span> <span class="s2">&quot;Unknown eye string &#39;</span><span class="si">%s</span><span class="s2">&#39;: Choose from &#39;LE&#39;, &#39;RE&#39;.&quot;</span> <span class="o">%</span> <span class="n">eye</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e_s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eye</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;LE&#39;</span><span class="p">:</span>
        <span class="c1"># The Jansonius model doesn&#39;t know about left eyes: We invert the x</span>
        <span class="c1"># coordinate of the optic disc here, run the model, and then invert all</span>
        <span class="c1"># x coordinates of all axon fibers back.</span>
        <span class="n">loc_od</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phi0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">180.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;phi0 must be within [-180, 180].&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_rho</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of radial sampling points must be &gt;= 1.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rho_range</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rho cannot be negative.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rho_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rho_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower bound on rho cannot be larger than the &#39;</span>
                         <span class="s1">&#39; upper bound.&#39;</span><span class="p">)</span>
    <span class="n">is_superior</span> <span class="o">=</span> <span class="n">phi0</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">rho_range</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_rho</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_superior</span><span class="p">:</span>
        <span class="c1"># Axon is in superior retina, compute `b` (real number) from Eq. 5:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">beta_sup</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">phi0</span> <span class="o">-</span> <span class="mf">121.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">14.0</span><span class="p">))</span>
        <span class="c1"># Equation 3, `c` a positive real number:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mf">1.9</span> <span class="o">+</span> <span class="mf">1.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">phi0</span> <span class="o">-</span> <span class="mf">121.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">14.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Axon is in inferior retina: compute `b` (real number) from Eq. 6:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">beta_inf</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">phi0</span> <span class="o">-</span> <span class="mf">90.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.0</span><span class="p">))</span>
        <span class="c1"># Equation 4, `c` a positive real number:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="o">-</span><span class="n">phi0</span> <span class="o">-</span> <span class="mf">90.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.0</span><span class="p">)</span>

    <span class="c1"># Spiral as a function of `rho`:</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">phi0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">rho</span> <span class="o">-</span> <span class="n">rho</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">**</span> <span class="n">c</span>

    <span class="c1"># Convert to Cartesian coordinates</span>
    <span class="n">xprime</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
    <span class="n">yprime</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="c1"># Find the array elements where the axon crosses the meridian</span>
    <span class="k">if</span> <span class="n">is_superior</span><span class="p">:</span>
        <span class="c1"># Find elements in inferior retina</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yprime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Find elements in superior retina</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">yprime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="c1"># Keep only up to first occurrence</span>
        <span class="n">xprime</span> <span class="o">=</span> <span class="n">xprime</span><span class="p">[:</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">yprime</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[:</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="c1"># Adjust coordinate system, having fovea=[0, 0] instead of `loc_od`=[0, 0]</span>
    <span class="n">xmodel</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">+</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span> <span class="o">=</span> <span class="n">yprime</span>
    <span class="k">if</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># If x-coordinate of optic disc is positive, use Appendix A</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else we need to flip the sign</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">loc_od</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># In a left eye, need to flip back x coordinates:</span>
    <span class="k">if</span> <span class="n">eye</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;LE&#39;</span><span class="p">:</span>
        <span class="n">xmodel</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Return as Nx2 array</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xmodel</span><span class="p">,</span> <span class="n">ymodel</span><span class="p">))</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="find_closest_axon"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.find_closest_axon">[docs]</a><span class="k">def</span> <span class="nf">find_closest_axon</span><span class="p">(</span><span class="n">pos_xy</span><span class="p">,</span> <span class="n">axon_bundles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finds the closest axon to a 2D point</span>

<span class="sd">    This function finds the axon bundle closest to a 2D point `pos_xy` on the</span>
<span class="sd">    retina, and returns an axon that originates in `pos_xy` and projects to</span>
<span class="sd">    the optic disc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pos_xy: (x, y)</span>
<span class="sd">        2D Cartesian coordinates of a location on the retina.</span>
<span class="sd">    axon_bundles: list of Nx2 arrays</span>
<span class="sd">        List of two - dimensional arrays containing the(x, y) coordinates of</span>
<span class="sd">        each axon bundle. The first row of each axon bundle is assumed to</span>
<span class="sd">        be closest to the optic disc, and subsequent row indices move the axon</span>
<span class="sd">        away from the optic disc.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    axon: Nx2 array</span>
<span class="sd">        A single axon, where axon[0, :] contains the (x, y) coordinates of the</span>
<span class="sd">        location closest to `pos_xy`, and all subsequent rows move the axon</span>
<span class="sd">        closer to the optic disc.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The order of axonal segments in the output argument `axon` is reversed</span>
<span class="sd">    with respect to the axonal segments in the input argument `axon_bundles`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xneuron</span><span class="p">,</span> <span class="n">yneuron</span> <span class="o">=</span> <span class="n">pos_xy</span>
    <span class="c1"># Find the nearest axon to this pixel</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">((</span><span class="n">ax</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xneuron</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ax</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yneuron</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axon_bundles</span><span class="p">]</span>
    <span class="n">axon_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>

    <span class="c1"># Find the position on the axon</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axon_bundles</span><span class="p">[</span><span class="n">axon_id</span><span class="p">]</span>
    <span class="n">dist2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xneuron</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ax</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yneuron</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">pos_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>

    <span class="c1"># Add all positions: from `pos_id` to the optic disc</span>
    <span class="k">return</span> <span class="n">axon_bundles</span><span class="p">[</span><span class="n">axon_id</span><span class="p">][</span><span class="n">pos_id</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="axon_dist_from_soma"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.axon_dist_from_soma">[docs]</a><span class="k">def</span> <span class="nf">axon_dist_from_soma</span><span class="p">(</span><span class="n">axon</span><span class="p">,</span> <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the distance to soma for every axon segment</span>

<span class="sd">    For every segment of an axon, this function calculates the distance to the</span>
<span class="sd">    soma. The 2D coordinates of the axon are snapped to the grid using a</span>
<span class="sd">    nearest-neighbor tree structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    axon: Nx2 array</span>
<span class="sd">        A single axon, where axon[0, :] contains the (x, y) coordinates of the</span>
<span class="sd">        location closest to the soma, and all subsequent rows move the axon</span>
<span class="sd">        away from the soma towards the optic disc.</span>
<span class="sd">    xg, yg: array</span>
<span class="sd">        meshgrid of pixel locations in units of visual angle sp</span>
<span class="sd">    tree : spat.cKDTree class instance, optional, default: train on `xg`, `yg`</span>
<span class="sd">        A kd-tree trained on `xg`, `yg` for quick nearest-neighbor lookup.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx_cs : list</span>
<span class="sd">        Axon segment locations snapped to the grid, returned as a list of</span>
<span class="sd">        indices into the flat `xg`, `yg` meshgrid.</span>
<span class="sd">    dist : list</span>
<span class="sd">        Axon segment distances to the soma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Build a nearest-neighbor tree for the coordinate system</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yg</span><span class="o">.</span><span class="n">ravel</span><span class="p">())))</span>

    <span class="c1"># Consider only pixels within the grid, otherwise snap to grid might</span>
    <span class="c1"># yield unexpected results</span>
    <span class="n">idx_valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">axon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xg</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="n">axon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xg</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">idx_valid</span> <span class="o">*=</span> <span class="p">(</span><span class="n">axon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">yg</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="n">axon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yg</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># For these, find the xg, yg coordinates</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">idx_cs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">axon</span><span class="p">[</span><span class="n">idx_valid</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_cs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Drop duplicates</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">idx_cs_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx_cs</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">idx_cs</span> <span class="o">=</span> <span class="n">idx_cs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx_cs_unique</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_cs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Find the location of the soma, based on the first axon segment</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">idx_neuron</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">axon</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># Calculate the distance to soma.</span>
    <span class="c1"># For distance calculation, add a pixel at the location of the soma:</span>
    <span class="n">idx_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx_cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx_neuron</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># For every axon segment, calculate distance from soma by summing up the</span>
    <span class="c1"># individual distances between neighboring axon segments (&quot;walking along</span>
    <span class="c1"># the axon&quot;):</span>
    <span class="n">xdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx_dist</span><span class="p">])</span>
    <span class="n">ydiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx_dist</span><span class="p">])</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">xdiff</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ydiff</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">idx_cs</span><span class="p">,</span> <span class="n">dist</span></div>


<div class="viewcode-block" id="axon_contribution"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.axon_contribution">[docs]</a><span class="k">def</span> <span class="nf">axon_contribution</span><span class="p">(</span><span class="n">axon_dist</span><span class="p">,</span> <span class="n">current_spread</span><span class="p">,</span> <span class="n">sensitivity_rule</span><span class="o">=</span><span class="s1">&#39;decay&#39;</span><span class="p">,</span>
                      <span class="n">contribution_rule</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">min_contribution</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                      <span class="n">decay_const</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">powermean_exp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines the contribution of a single axon to the current map</span>

<span class="sd">    This function determines the contribution of a single axon to the current</span>
<span class="sd">    map based on a sensitivity rule (i.e., how the activation threshold of the</span>
<span class="sd">    axon differs as a function of distance from the soma), and an contribution</span>
<span class="sd">    rule (i.e., how the different activation thresholds along the axon are</span>
<span class="sd">    combined to determine the axon contribution).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    axon_dist : tuple (indices, distances)</span>
<span class="sd">        A tuple containing a list of coordinates (indices into the retinal</span>
<span class="sd">        coordinates mesh grid) and distances for each axon segment.</span>
<span class="sd">    current_spread : 2D array</span>
<span class="sd">        A 2D current spread map that must have the same dimensions as the</span>
<span class="sd">        `xg`, `yg` meshgrid.</span>
<span class="sd">    sensitivity_rule : {&#39;decay&#39;, &#39;Jeng2011&#39;}, optional, default: &#39;decay&#39;</span>
<span class="sd">        This rule specifies how the activation of the axon differs as a</span>
<span class="sd">        function of distance from the soma. The following options are</span>
<span class="sd">        available:</span>
<span class="sd">        - &#39;decay&#39;:</span>
<span class="sd">            Axon sensitivity decays exponentially with distance. Specify</span>
<span class="sd">            `decay_const` to change the steepness of the fall-off with</span>
<span class="sd">            distance.</span>
<span class="sd">        - &#39;Jeng2011&#39;:</span>
<span class="sd">            Axon sensitivity peaks near the sodium band (50um from the soma),</span>
<span class="sd">            then plateaus on the distal axon at roughly half of the peak</span>
<span class="sd">            sensitivity. See Figure 2 in Jeng, Tang, Molnar, Desai, and Fried</span>
<span class="sd">            (2011). The sodium channel band shapes the response to electric</span>
<span class="sd">            stimulation in retinal ganglion cells. J Neural Eng 8 (036022).</span>
<span class="sd">    contribution_rule : {&#39;max&#39;, &#39;sum&#39;, &#39;power-mean&#39;}, optional, default: &#39;max&#39;</span>
<span class="sd">        This rule specifies how the activation thresholds across all axon</span>
<span class="sd">        segments are combined to determine the contribution of the axon to the</span>
<span class="sd">        current spread. The following options are available:</span>
<span class="sd">        - &#39;max&#39;:</span>
<span class="sd">            The axon&#39;s contribution to the current spread is equal to the max.</span>
<span class="sd">            sensitivity across all axon segments.</span>
<span class="sd">        - &#39;sum&#39;:</span>
<span class="sd">            The axon&#39;s contribution to the current spread is equal to the sum</span>
<span class="sd">            sensitivity across all axon segments.</span>
<span class="sd">        - &#39;mean&#39;:</span>
<span class="sd">            The axon&#39;s contribution to the current spread is equal to the mean</span>
<span class="sd">            sensitivity across all axon segments. Specify `powermean_exp` to</span>
<span class="sd">            change the exponent of the generalized (power) mean, calculated as</span>
<span class="sd">            np.mean(x ** powermean_exp) ** (1.0 / powermean_exp).</span>
<span class="sd">    min_contribution : float, optional, default: 0.01</span>
<span class="sd">        Current contributions below this value will not be counted.</span>
<span class="sd">    decay_const : float, optional, default: 2.0</span>
<span class="sd">        When `sensitivity_rule` is set to &#39;decay&#39;, specifies the decay constant</span>
<span class="sd">        of the exponential fall-off.</span>
<span class="sd">    powermean_exp : float, optional, default: None</span>
<span class="sd">        When `sensitivity_rule` is set to &#39;mean&#39;, specifies the exponent of the</span>
<span class="sd">        generalized (power) mean function. The power mean is calculated as</span>
<span class="sd">        np.mean(x ** powermean_exp) ** (1.0 / powermean_exp).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">contribution_rule</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">powermean_exp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`powermean_exp` cannot be None when contribution &quot;</span>
                             <span class="s2">&quot;rule is set to &#39;mean&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">powermean_exp</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`powermean_exp` must be positive.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">powermean_exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Contribution rule must be set to &#39;mean&#39; in &quot;</span>
                              <span class="s2">&quot;order to change `powermean_exp` (currently &quot;</span>
                              <span class="s2">&quot;set to </span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="n">contribution_rule</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">decay_const</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`decay_const` must be positive.&#39;</span><span class="p">)</span>

    <span class="c1"># Unpack list of indices and distances for each axon segment</span>
    <span class="n">idx_cs</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">axon_dist</span>
    <span class="n">idx_soma</span> <span class="o">=</span> <span class="n">idx_cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># The sensitivity rule specifies how the activation thresholds differs</span>
    <span class="c1"># along the axon:</span>
    <span class="k">if</span> <span class="n">sensitivity_rule</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;decay&#39;</span><span class="p">:</span>
        <span class="c1"># Exponential fall-off with distance</span>
        <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span> <span class="o">/</span> <span class="n">decay_const</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sensitivity_rule</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;jeng2011&#39;</span><span class="p">:</span>
        <span class="c1"># Roughly the inverse of Figure 2 in Jeng et al. (2011): The peak</span>
        <span class="c1"># sensitivity is over the sodium band, and the sensitivity of the</span>
        <span class="c1"># distal axon plateaus at roughly 50% of peak</span>
        <span class="n">mu_gauss</span> <span class="o">=</span> <span class="n">ret2dva</span><span class="p">(</span><span class="mf">50.0</span><span class="p">)</span>
        <span class="n">std_gauss</span> <span class="o">=</span> <span class="n">ret2dva</span><span class="p">(</span><span class="mf">20.0</span><span class="p">)</span>
        <span class="n">bell</span> <span class="o">=</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">mu_gauss</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">std_gauss</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">plateau</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">soma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mu_gauss</span> <span class="o">-</span> <span class="n">dist</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bell</span> <span class="o">-</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">+</span> <span class="n">plateau</span> <span class="o">-</span> <span class="n">soma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown sensitivity rule &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">sensitivity_rule</span><span class="p">)</span>

    <span class="c1"># Effective activation of all axon segments, given by the segment&#39;s</span>
    <span class="c1"># sensitivity and activating current</span>
    <span class="n">activation</span> <span class="o">=</span> <span class="n">sensitivity</span> <span class="o">*</span> <span class="n">current_spread</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx_cs</span><span class="p">]</span>

    <span class="c1"># The contribution rule specifies how the activation values along the axon</span>
    <span class="c1"># are combined to determine the contribution of the axon to the current</span>
    <span class="c1"># spread:</span>
    <span class="k">if</span> <span class="n">contribution_rule</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">contribution</span> <span class="o">=</span> <span class="n">activation</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">contribution_rule</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">contribution</span> <span class="o">=</span> <span class="n">activation</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">contribution_rule</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="c1"># Generalized (power) mean</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">powermean_exp</span>
        <span class="n">contribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">activation</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown activation rule &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">contribution_rule</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">idx_soma</span><span class="p">,</span> <span class="n">contribution</span></div>


<div class="viewcode-block" id="jansonius"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.jansonius">[docs]</a><span class="nd">@utils</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="n">alt_func</span><span class="o">=</span><span class="s1">&#39;p2p.retina.jansonius2009&#39;</span><span class="p">,</span>
                  <span class="n">deprecated_version</span><span class="o">=</span><span class="s1">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">removed_version</span><span class="o">=</span><span class="s1">&#39;0.4&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">jansonius</span><span class="p">(</span><span class="n">num_cells</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">801</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
              <span class="n">rot</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bs</span><span class="o">=-</span><span class="mf">1.9</span><span class="p">,</span> <span class="n">bi</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">r0</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
              <span class="n">max_samples</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ang_range</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the model of retinal axonal pathways by generating a</span>
<span class="sd">    matrix of(x, y) positions.</span>

<span class="sd">    Assumes that the fovea is at[0, 0]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_cells: int</span>
<span class="sd">        Number of axons(cells).</span>
<span class="sd">    num_samples: int</span>
<span class="sd">        Number of samples per axon(spatial resolution).</span>
<span class="sd">    Center: 2 item array</span>
<span class="sd">        The location of the optic disk in dva.</span>

<span class="sd">    See:</span>

<span class="sd">    Jansonius et al., 2009, A mathematical description of nerve fiber bundle</span>
<span class="sd">    trajectories and their variability in the human retina, Vision Research</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default parameters:</span>
    <span class="c1">#</span>
    <span class="c1"># r0 = 4;             %Minumum radius (optic disc size)</span>
    <span class="c1">#</span>
    <span class="c1"># center = [15,2];    %p.center of optic disc</span>
    <span class="c1">#</span>
    <span class="c1"># rot = 0*pi/180;    %Angle of rotation (clockwise)</span>
    <span class="c1"># scale = 1;             %Scale factor</span>
    <span class="c1">#</span>
    <span class="c1"># bs = -1.9;          %superior &#39;b&#39; parameter constant</span>
    <span class="c1"># bi = .5;            %inferior &#39;c&#39; parameter constant</span>
    <span class="c1"># ang_range = 60</span>

    <span class="c1"># sample space of superior/inferior retina, add them in a 1D array</span>
    <span class="c1"># superior is where ang0 &gt; 0</span>
    <span class="c1"># this will be the first dimension of the meshgrid</span>
    <span class="c1"># inferior should go from -180 to -60? or typo in paper</span>
    <span class="c1"># ang0 is \phi_0</span>
    <span class="n">ang0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ang_range</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">num_cells</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># superior</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="n">ang_range</span><span class="p">,</span> <span class="n">num_cells</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># inferior</span>

    <span class="c1"># from r0=4 to max_samples=45, take num_samples=801 steps</span>
    <span class="c1"># this will be the second dimension of the meshgrid</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">max_samples</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>

    <span class="c1"># generate angle and radius matrices from vectors with meshgrid</span>
    <span class="n">ang0mat</span><span class="p">,</span> <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ang0</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">ang0mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_cells</span> <span class="o">=</span> <span class="n">ang0mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># index into axons from superior (upper) retina</span>
    <span class="n">sup</span> <span class="o">=</span> <span class="n">ang0mat</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Set up &#39;b&#39; parameter:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>

    <span class="c1"># Equation 5: upper retina</span>
    <span class="n">b</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="n">bs</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">ang0mat</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">121</span><span class="p">)</span> <span class="o">/</span> <span class="mi">14</span><span class="p">))</span>

    <span class="c1"># equation 6: lower retina</span>
    <span class="n">b</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bi</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">ang0mat</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">))</span>

    <span class="c1"># Set up &#39;c&#39; parameter:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>

    <span class="c1"># equation 3 (fixed typo)</span>
    <span class="c1"># Paper says -(angmat-121)/14. Is the - sign the typo?</span>
    <span class="n">c</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.9</span> <span class="o">+</span> <span class="mf">1.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">ang0mat</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">121</span><span class="p">)</span> <span class="o">/</span> <span class="mi">14</span><span class="p">)</span>
    <span class="n">c</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="o">-</span><span class="n">ang0mat</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span>   <span class="c1"># equation 4</span>

    <span class="c1"># Here&#39;s the main function: spirals as a function of r (equation 1)</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">ang0mat</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">rmat</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span><span class="o">**</span><span class="n">c</span>

    <span class="c1"># Transform to x-y coordinates</span>
    <span class="n">xprime</span> <span class="o">=</span> <span class="n">rmat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>
    <span class="n">yprime</span> <span class="o">=</span> <span class="n">rmat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>

    <span class="c1"># Find where the fibers cross the horizontal meridian</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">])</span>
    <span class="n">cross</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="n">sup</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">cross</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="o">~</span><span class="n">sup</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Set Nans to axon paths after crossing horizontal meridian</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cross</span><span class="p">))</span>

    <span class="n">curr_col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># loop through axons</span>
        <span class="k">if</span> <span class="n">curr_col</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">yprime</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:,</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
            <span class="n">curr_col</span> <span class="o">=</span> <span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Bend the image according to (the inverse) of Appendix A</span>
    <span class="n">xmodel</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span> <span class="o">=</span> <span class="n">yprime</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">xprime</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ymodel</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">yprime</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">/</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1">#  rotate about the optic disc and scale</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ymodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ymodel</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="make_axon_map"><a class="viewcode-back" href="../../reference/pulse2percept.retina.html#pulse2percept.retina.make_axon_map">[docs]</a><span class="nd">@utils</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="n">deprecated_version</span><span class="o">=</span><span class="s1">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">removed_version</span><span class="o">=</span><span class="s1">&#39;0.4&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">make_axon_map</span><span class="p">(</span><span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="n">jan_x</span><span class="p">,</span> <span class="n">jan_y</span><span class="p">,</span> <span class="n">axon_lambda</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_weight</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retinal axon map</span>

<span class="sd">    Generates a mapping of how each pixel in the retina space is affected</span>
<span class="sd">    by stimulation of underlying ganglion cell axons.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xg, yg: array</span>
<span class="sd">        meshgrid of pixel locations in units of visual angle sp</span>
<span class="sd">    axon_lambda: float</span>
<span class="sd">        space constant for how effective stimulation(or &#39;weight&#39;) falls off</span>
<span class="sd">        with distance from the pixel back along the axon toward the optic disc</span>
<span class="sd">        (default 1 degree)</span>
<span class="sd">    min_weight: float</span>
<span class="sd">        minimum weight falloff.  default .001</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    axon_id: list</span>
<span class="sd">        a list, for every pixel, of the index into the pixel in xg, yg space,</span>
<span class="sd">        along the underlying axonal pathway.</span>
<span class="sd">    axon_weight: list</span>
<span class="sd">        a list, for every pixel, of the axon weight into the pixel in xg, yg</span>
<span class="sd">        space</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axon_id</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axon_weight</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
        <span class="n">cur_xg</span> <span class="o">=</span> <span class="n">xg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">cur_yg</span> <span class="o">=</span> <span class="n">yg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># find the nearest axon to this pixel</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_x</span> <span class="o">-</span> <span class="n">cur_xg</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">jan_y</span> <span class="o">-</span> <span class="n">cur_yg</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">cur_ax_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># index into the current axon</span>

        <span class="c1"># `ax_num`: which axon it is</span>
        <span class="c1"># `ax_pos_id0`: the point on that axon that is closest to `px`</span>
        <span class="p">[</span><span class="n">ax_pos_id0</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">cur_ax_id</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">this_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">this_weight</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ax_pos_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ax_pos_id0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Increment the distance from the starting point</span>
            <span class="c1"># The following calculation had a bug in them: squaring was done</span>
            <span class="c1"># twice</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="p">(</span><span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">dist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ax</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ay</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># weight falls off exponentially as distance from axon cell body</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span> <span class="o">/</span> <span class="n">axon_lambda</span><span class="p">)</span>

            <span class="c1"># find the nearest pixel to the current position along the axon</span>
            <span class="n">dist_xg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">jan_x</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">dist_yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yg</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">jan_y</span><span class="p">[</span><span class="n">ax_pos_id</span><span class="p">,</span> <span class="n">ax_num</span><span class="p">])</span>
            <span class="n">nearest_xg_id</span> <span class="o">=</span> <span class="n">dist_xg</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">nearest_yg_id</span> <span class="o">=</span> <span class="n">dist_yg</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">nearest_xg</span> <span class="o">=</span> <span class="n">xg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nearest_xg_id</span><span class="p">]</span>
            <span class="n">nearest_yg</span> <span class="o">=</span> <span class="n">yg</span><span class="p">[</span><span class="n">nearest_yg_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># if the position along the axon has moved to a new pixel, and the</span>
            <span class="c1"># weight isn&#39;t too small...</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="n">min_weight</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nearest_xg</span> <span class="o">!=</span> <span class="n">cur_xg</span> <span class="ow">or</span> <span class="n">nearest_yg</span> <span class="o">!=</span> <span class="n">cur_yg</span><span class="p">:</span>
                    <span class="c1"># update the current pixel location</span>
                    <span class="n">cur_xg</span> <span class="o">=</span> <span class="n">nearest_xg</span>
                    <span class="n">cur_yg</span> <span class="o">=</span> <span class="n">nearest_yg</span>

                    <span class="c1"># Append the list</span>
                    <span class="c1"># The following calculation had a bug in it: `weight` was</span>
                    <span class="c1"># exponentiated twice</span>
                    <span class="n">this_weight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                    <span class="n">this_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">nearest_yg_id</span><span class="p">,</span>
                                                         <span class="n">nearest_xg_id</span><span class="p">),</span>
                                                        <span class="n">xg</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">axon_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_id</span><span class="p">)</span>
        <span class="n">axon_weight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axon_id</span><span class="p">,</span> <span class="n">axon_weight</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Beyeler, Ariel Rokem, Geoff Boynton, and Ione Fine, The University of Washington.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>